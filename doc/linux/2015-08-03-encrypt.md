
### 什么是加密？

> * 单钥加密（private key cryptography）
> * 双钥加密（public key cryptography）

前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。

+ 单钥加密
+ 双钥加密，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。公钥用来加密信息，私钥用来数字签名。  

双钥加密的原理如下：  
a) 公钥和私钥是一一对应的关系  
b) 所有的（公钥, 私钥）对都是不同的。  
c) 用公钥可以解开私钥加密的信息，反之亦成立。  
d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。  

通用的单钥加密算法为DES（Data Encryption Standard）。  
通用的双钥加密算法为RSA（Rivest-Shamir-Adleman）。

### 什么是数字签名 & 数字证书

"数字签名"（digital signature）和"数字证书"（digital certificate）到底是什么？

#### 什么是数字签名

所谓数字签名，就是对原始文件的"指纹"(如md5值)进行了私钥加密。这样，即可保证文件的特征(摘要值)一定经过了私钥的加密。同时由于信息摘要的长度普遍不长（MD5为128位，SHA1主要为256位），也并没有带来太大的开销。

下面用一个例子来说明

1. 假设我们的主人公叫做A，A有两把钥匙：公钥、私钥
2. 一天，A先生把他的公钥送给了他的同事路人甲和女友B
3. 现在女朋友B就可以写信*我想你*，然后经过公钥加密，生成*ASDFWEFVC/asdf*，然后发给咱们的A先生
4. A先生收到这封密信*ASDFWEFVC/asdf*，拿出自己的私钥即可解码回*我想你*。这个过程中只要A先生自己的私钥不丢失，信件内容就能保证安全性
5. 当A先生收到小美的信件后，打算回信给小米，这时候A先生打算使用**数字签名**给自己的信件打个印记。A先生是这么做的，当他写完回信后，使用 `Hash` 算法生成一段固定长度字符串作为信件的摘要
6. 然后A先生，再将这个摘要用自己的私钥进行加密，这就是**数字签名**，然后将这个数字签名连同上面的回信一同发给女朋友B
7. B在收到A先生的回信后，先拿到信件上附加的数字签名，使用自己手中的公钥进行解码，获取到一个结果。然后再对信件本身进行 `Hash` 运算，将得到的结果与之前的通过数字签名得到的结果进行比较，如果一致就说明该信件未被他人修改过

#### 什么是数字证书

上面只是一种理想状态，如果路人甲起了歪心思......

1. 路人甲首先偷偷打开了B的电脑，把B电脑里A先生的公钥删除，然后换上了自己的公钥。
2. 现在，B再使用所谓A先生的公钥，其实已经变成了路人甲的公钥
3. 路人甲这时候就可以冒充A先生，用自己的私钥来制作**数字签名**，写信给B，B会误以为这是A先生的来信
4. 天网恢恢疏而不漏，慢慢的，B开始觉得有点不对，怎么信件的文风大变？这时，也许B就会发现在这套逻辑里存在一个致命问题，那就是她无法确定自己手里的公钥到底是谁的。这时候就只能让公正不阿的公先生——**证书中心（certificate authority，简称CA）**出场了，让 CA 给A先生的公钥做个认证。
5. CA 用自己的私钥，对A先生的公钥以及另外一些基本信息进行加密，生成的即**数字证书**
6. 现在A先生感觉自然棒棒哒，以后再写信给小美，只要在进行数字签名的同时，再附上数字证书就行了
7. B收到信后，先用 CA 的公钥解开数字证书，就可以拿到A先生的公钥，然后再用A先生的公钥去解开数字签名，最终就可以确认这封信是不是A先生的亲笔了......


数字证书相当于物理世界中的身份证，
在网络中传递信息的双方互相不能见面，利用数字证书可确认双方身份，而不是他人冒充的。

这个数字证书由信任的第三方，即认证中心使用自己的私钥对A的公钥加密，加密后文件就是网络上的身份证了，即数字证书


### https 是啥

1. 浏览器向服务器发出加密请求
2. 服务器将网页用自己的密钥进行加密后，连同自己的数字证书一同返给客户端
3. 浏览器的“证书管理器”中有“受信任的根证书颁发机构”列表，客户端在接收到响应后，会在这个列表里查看是否存在解开该服务器数字证书的公钥。有两种错误情况：如果公钥在这个列表里，但是解码后的内容不匹配，说明证书被冒用；如果公钥不在这个列表里，说明这张证书不是受信任的机构所颁发，他的真实性无法确定
4. 如果一切都没问题，浏览器就可以使用服务器的公钥对信息内容进行加密，然后与服务器交换信息（已加密）

### 常用的证书密钥库格式

> * JKS和JCEKS是Java密钥库(KeyStore)的两种比较常见类型，JKS的Provider是SUN，在每个版本的JDK中都有，JCEKS的Provider是SUNJCE，1.4后我们都能够直接使用它。 
> * JCEKS在安全级别上要比JKS强，使用的Provider是JCEKS(推荐)，尤其在保护KeyStore中的私钥上（使用TripleDES） 
> * PFX（PKCS#12）是公钥加密标准，它规定了可包含所有私钥、公钥和证书。其以二进制格式存储，在windows中可以直接导入到密钥区，注意，PKCS#12的密钥库保护密码同时也用于保护Key。 
> * BKS 来自BouncyCastleProvider，它使用的也是TripleDES来保护密钥库中的Key，它能够防止证书库被不小心修改（Keystore的keyentry改掉1个bit都会产生错误），BKS能够跟JKS互操作。 
> * UBER 比较特别，当密码是通过命令行提供的时候，它只能跟keytool交互。整个keystore是通过PBE/SHA1/Twofish加密，因此 keystore能够防止被误改、察看以及校验。SunJDK允许你在不提供密码的情况下直接加载一个Keystore，类似cacerts，UBER不 允许这种情况。 


#### 常见问题

***java.security.UnrecoverableKeyException: Cannot recover key***

此错误由调用getKey（alias,aliaspassword）函数抛出。
可能原因为aliaspassword的密码不正确，
注意aliaspassword必须是aias数字证书的密码。而不是keystore的密码。

keystore 证书里有两个密码，一个是keystore密码，一个是aias数字证书的密码，直接设置为一样的
